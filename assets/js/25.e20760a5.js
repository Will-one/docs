(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{566:function(s,t,e){"use strict";e.r(t);var a=e(10),r=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"p19-模块化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#p19-模块化"}},[s._v("#")]),s._v(" p19 模块化")]),s._v(" "),e("p",[s._v("遵循固定的规则, 把一个大文件拆成独立并互相依赖的多个小模块")]),s._v(" "),e("p",[s._v("模块化的优点")]),s._v(" "),e("ol",[e("li",[s._v("提高了代码的复用性")]),s._v(" "),e("li",[s._v("提高了代码的可维护性")]),s._v(" "),e("li",[s._v("可以实现按需加载")])]),s._v(" "),e("h3",{attrs:{id:"模块化规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化规范"}},[s._v("#")]),s._v(" 模块化规范")]),s._v(" "),e("p",[s._v("模块化规范就是对代码进行模块化的拆分与组合时,需要遵守的那些规则")]),s._v(" "),e("p",[s._v("例如:")]),s._v(" "),e("ul",[e("li",[s._v("使用什么样的语法格式来引用模块")]),s._v(" "),e("li",[s._v("在模块中使用什么样的语法格式向外暴露成员")])]),s._v(" "),e("p",[s._v("模块化规范的好处: 大家都遵守同样的模块化规范写代码, 降低了沟通的成本, 极大方便了各个模块之间的相互调用.")]),s._v(" "),e("h2",{attrs:{id:"p20-模块分类和require加载模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#p20-模块分类和require加载模块"}},[s._v("#")]),s._v(" p20 模块分类和require加载模块")]),s._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 1. 加载内置模块")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" fs "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'fs'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 2. 加载自定义模块")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" custom "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'./modules/custom.js'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 3. 加载第三方模块")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" moment "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'moment'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])])]),e("h2",{attrs:{id:"p21-模块作用域和module对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#p21-模块作用域和module对象"}},[s._v("#")]),s._v(" p21 模块作用域和module对象")]),s._v(" "),e("h3",{attrs:{id:"模块作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块作用域"}},[s._v("#")]),s._v(" 模块作用域:")]),s._v(" "),e("p",[s._v("和函数作用域类似, 在自定义模块中定义的变量, 方法等成员, 只能在当前模块中被访问, 这种模块级别的访问限制,叫做模块作用域")]),s._v(" "),e("p",[s._v("好处:")]),s._v(" "),e("ul",[e("li",[s._v("防止全局变量污染的问题")])]),s._v(" "),e("h3",{attrs:{id:"module对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#module对象"}},[s._v("#")]),s._v(" module对象")]),s._v(" "),e("p",[s._v("在每个.js 自定义模块中都有一个module对象,它里面存储了和当前模块有关的信息.")]),s._v(" "),e("h2",{attrs:{id:"p22-module-exports-对象的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#p22-module-exports-对象的使用"}},[s._v("#")]),s._v(" P22 module.exports 对象的使用")]),s._v(" "),e("p",[s._v("在自定义模块中, 可以使用module.exports对象, 将模块内的成员共享出去, 供外界使用")]),s._v(" "),e("p",[s._v("外界用require()方法导入自定义模块时, 得到的就是module.exports 所指向的对象")]),s._v(" "),e("h2",{attrs:{id:"p23-p24-exports-对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#p23-p24-exports-对象"}},[s._v("#")]),s._v(" P23-P24 exports 对象")]),s._v(" "),e("p",[s._v("由于module.exports 写起来复杂, node提供了exports对象.")]),s._v(" "),e("p",[s._v("默认情况下 exports 和 module.exports 指向同一个对象. 最终导入的对象是module.exports指向的对象")]),s._v(" "),e("h2",{attrs:{id:"p25-commonjs-模块化规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#p25-commonjs-模块化规范"}},[s._v("#")]),s._v(" P25 CommonJS 模块化规范")]),s._v(" "),e("p",[s._v("Node.js 遵循了CommonJS模块化规范, CommonJS 规定了模块的特性和各模块之间如何相互依赖")]),s._v(" "),e("p",[s._v("CommonJS 规定:")]),s._v(" "),e("ol",[e("li",[s._v("每个模块内部, module 变量代表当前模块")]),s._v(" "),e("li",[s._v("module变量是一个对象, 他的exports属性(即module.exports)是对外的接口")]),s._v(" "),e("li",[s._v("加载某个模块,其实是加载该模块的module.exports 属性. require() 方法用于加载模块")])]),s._v(" "),e("h2",{attrs:{id:"p37-模块的加载机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#p37-模块的加载机制"}},[s._v("#")]),s._v(" p37 模块的加载机制")]),s._v(" "),e("ol",[e("li",[e("p",[s._v("优先从缓存中加载\n模块在第一次加载后会被缓存。这也意味着多次调用require()不会导致模块的代码被执行多次")]),s._v(" "),e("p",[s._v("注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会预先从缓存中加载，从而提高模块的加载效率")])]),s._v(" "),e("li",[e("p",[s._v("内置模块的加载机制\n内置模块是 Node.js 官方提供的模块，内置模块的加载优先级最高。")]),s._v(" "),e("p",[s._v("例如：require('fs')始终返回内置的fs 模块，即使在 node_modules 目录下的名字相同的包也叫做fs")])]),s._v(" "),e("li",[e("p",[s._v("自定义模块的加载机制\n使用 require() 加载自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下文档。")]),s._v(" "),e("ol",[e("li",[s._v("按照确切的文件名进行加载")]),s._v(" "),e("li",[s._v("补全 .js 扩展名进行加载")]),s._v(" "),e("li",[s._v("补全 .json 进行加载")]),s._v(" "),e("li",[s._v(".node 进行加载")]),s._v(" "),e("li",[s._v("加载失败，终端报错")])])]),s._v(" "),e("li",[e("p",[s._v("第三方模块的加载机制\n不是内置模块，也没有./../开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件中加载第三方模块")]),s._v(" "),e("p",[s._v("如果没有找到对应的第三方模块，则移动到再上一层目录中，进行加载，知道文件系统的根目录")])]),s._v(" "),e("li",[e("p",[s._v("目录作为模块\n当把目录作为模块标识符，传递给require()进行加载的时候，有三种加载方式：")]),s._v(" "),e("ol",[e("li",[s._v("在被加载的目录下查找一个叫做package.json的文件，并寻找 main 属性，作为 require() 加载的入口")]),s._v(" "),e("li",[s._v("如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的index.js文件")]),s._v(" "),e("li",[s._v("如果以上都没有，则报错")])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);