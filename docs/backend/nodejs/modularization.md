---
title: '模块化'
categoris:
- backend
tages:
- nodejs
---

## p19 模块化
遵循固定的规则, 把一个大文件拆成独立并互相依赖的多个小模块

模块化的优点
1. 提高了代码的复用性
2. 提高了代码的可维护性
3. 可以实现按需加载

### 模块化规范
模块化规范就是对代码进行模块化的拆分与组合时,需要遵守的那些规则

例如:
* 使用什么样的语法格式来引用模块
* 在模块中使用什么样的语法格式向外暴露成员

模块化规范的好处: 大家都遵守同样的模块化规范写代码, 降低了沟通的成本, 极大方便了各个模块之间的相互调用.

## p20 模块分类和require加载模块
```js
// 1. 加载内置模块
const fs = require('fs')

// 2. 加载自定义模块
const custom = require('./modules/custom.js')

// 3. 加载第三方模块
const moment = require('moment')
```

## p21 模块作用域和module对象
### 模块作用域:
和函数作用域类似, 在自定义模块中定义的变量, 方法等成员, 只能在当前模块中被访问, 这种模块级别的访问限制,叫做模块作用域

好处:
   * 防止全局变量污染的问题

### module对象
在每个.js 自定义模块中都有一个module对象,它里面存储了和当前模块有关的信息.

## P22 module.exports 对象的使用
在自定义模块中, 可以使用module.exports对象, 将模块内的成员共享出去, 供外界使用

外界用require()方法导入自定义模块时, 得到的就是module.exports 所指向的对象

## P23-P24 exports 对象
由于module.exports 写起来复杂, node提供了exports对象. 

默认情况下 exports 和 module.exports 指向同一个对象. 最终导入的对象是module.exports指向的对象

## P25 CommonJS 模块化规范
Node.js 遵循了CommonJS模块化规范, CommonJS 规定了模块的特性和各模块之间如何相互依赖

CommonJS 规定:
1. 每个模块内部, module 变量代表当前模块
2. module变量是一个对象, 他的exports属性(即module.exports)是对外的接口
3. 加载某个模块,其实是加载该模块的module.exports 属性. require() 方法用于加载模块


## p37 模块的加载机制
1. 优先从缓存中加载
   模块在第一次加载后会被缓存。这也意味着多次调用require()不会导致模块的代码被执行多次

   注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会预先从缓存中加载，从而提高模块的加载效率

2. 内置模块的加载机制
   内置模块是 Node.js 官方提供的模块，内置模块的加载优先级最高。

   例如：require('fs')始终返回内置的fs 模块，即使在 node_modules 目录下的名字相同的包也叫做fs

3. 自定义模块的加载机制
   使用 require() 加载自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下文档。
   1. 按照确切的文件名进行加载
   2. 补全 .js 扩展名进行加载
   3. 补全 .json 进行加载
   4. .node 进行加载
   5. 加载失败，终端报错 

4. 第三方模块的加载机制
   不是内置模块，也没有./../开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件中加载第三方模块

   如果没有找到对应的第三方模块，则移动到再上一层目录中，进行加载，知道文件系统的根目录

5. 目录作为模块
   当把目录作为模块标识符，传递给require()进行加载的时候，有三种加载方式：
   1. 在被加载的目录下查找一个叫做package.json的文件，并寻找 main 属性，作为 require() 加载的入口
   2. 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的index.js文件
   3. 如果以上都没有，则报错